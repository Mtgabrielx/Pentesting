import socket
import sys
import threading
import hashlib
import getopt
import subprocess
import re

def uso():
    print("")
    print("Comandos:")
    print("")
    print('-h, --help     : help')
    print("-l, --listen   : escutar")
    print("-p, --porta    : definir porta")
    print("-t, --ip       : IP do alvo")
    print("-r, --recive   : receber um arquivo")
    print("-e, --execute  : executa um cmd")
    print("-f, --file     : envia um arquivo")
    print("-i, --file     : executar no localhost")
    print("")
    print(f"EX: python {__file__} -t 127.0.0.1 -p 80")
    print(f"EX: python {__file__} -l -p 8080")
    print(f"EX: python {__file__} -i -p 4444 -e")
    print(f"EX: python {__file__} -i -p 8080 -f teste.txt")
    print(f"EX: python {__file__} -t localhost -p 8080 -r")
    print("")

class SOCKET():
    
    @property
    def target_ip(self):
        return self._target_ip

    @target_ip.setter
    def target_ip(self, target_ip):
        try:
            self._target_ip = self.is_valid_ipv4(target_ip)
        except Exception as e:
            print(e,"\nIp inválido")
    
    def is_valid_ipv4(self,ip):
        ipv4_pattern = r'^(\d{1,3}\.){3}\d{1,3}$'
        if ip == "localhost":
            return ip
        elif re.match(ipv4_pattern, ip):
            octets = ip.split('.')
            for octet in octets:
                if int(octet) < 0 or int(octet) > 255:
                    raise Exception
            return ip
        else:
            raise Exception
        
    @property
    def port(self):
        return int(self._port)

    @port.setter
    def port(self,port):
        try:
            self._port = self.is_valid_port(port)
        except Exception as e:
            print(e,"\nPorta inválida")
    
    def is_valid_port(self,port):
        port = int(port)
        if port >= 65535 or port < 0:
            raise Exception
        return port
    
    def __init__(self):
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.my_ip = socket.gethostbyname(socket.gethostname())
        except Exception as e:
            print(e,"\nAlgo deu errado")

    def send_message(self,sock,mensage):
        try:
            sock.sendall(mensage.encode())
        except Exception as e:
            print(e,'\nErro ao enviar mensagem')

    def receive_message(self,sock):
        try:
            data =  sock.recv(4096).decode().strip()
            if not data:
                raise Exception
            return data
        except Exception as e:
            print(e,"Erro ao receber a mensagem")

    def stay_listen(self,sock):
        try:
            while True: print(self.receive_message(sock))
        except Exception as e:
            print(e)

    def stay_sending(self,sock):
        message_to_send = ""
        while message_to_send.lower() != "sair":
            message_to_send = input("")
            sock.sendall(message_to_send.encode())

    def connect_to_target(self):
        try:
            self.sock.connect((self.target_ip,self.port))
            print(f"Conectado ao {self.target_ip} na porta {self.port}")
            to_listen = threading.Thread(target=self.stay_listen,args=(self.sock,))
            to_listen.start()
            self.stay_sending(self.sock)

        except Exception as e: 
            print(e,"\nErro de conexão")

        finally:
            self.sock.close()

    def start_listen(self):
        try:
            self.sock.bind((self.my_ip,self.port))
            print(f"Escutando na porta {self.port}")
            self.sock.listen(1)
            self.target_socket , _ = self.sock.accept()
            thread_listen = threading.Thread(target=self.stay_listen,args=(self.target_socket,))
            thread_listen.start()
            self.stay_sending(self.target_socket)
        except Exception as e:
            print(e,"Erro ao criar escuta")

    def send_file(self,file):
        self.sock.bind((self.my_ip,self.port))
        self.sock.listen(1)
        self.target_socket, _ = self.sock.accept()
        md5 = self.compute_md5(file)
        self.send_message(self.target_socket,md5)
        self.delivered_successfully(file)

    def compute_md5(self,file):
        with open(file,'rb') as f:
            data = f.read()
            md5_return = hashlib.md5(data).hexdigest()
        return md5_return

    def delivered_successfully(self,file):
        with open(file,'rb') as f:
            compressed_file = f.read()
        try:
            self.target_socket.sendall(compressed_file)
            response = self.target_socket.recv(4096)
            if not response:
                raise Exception
            if "OK" in response.decode().strip():
                print("arquivo enviado!")
            else:
                print("Erro ao enviar arquivo")

        except Exception as e:
            print(e)

    def recv_file(self):
        self.sock.connect((self.target_ip,self.port))
        md5_origim = self.sock.recv(4096)
        file_buffer  = self.sock.recv(1024)        
        try:
            self.save_file(file_buffer)
            self.sock.send("OK".encode())
        except:print("Erro ao salvar")

    def save_file(self,file_buffer):
        arquivo = input("Nome do arquivo: ")
        save_file = open(arquivo,'wb')
        save_file.write(file_buffer)
        save_file.close()
        print("salvo com sucesso")

    def execute_command(self):
        self.sock.bind((self.my_ip,self.port))   
        self.sock.listen(1)
        self.target_socket, _ = self.sock.accept()
        while True:
            command = self.target_socket.recv(1024)
            response = self.shell_command(command.decode())
            self.target_socket.sendall((response+'\n').encode())
    
    def shell_command(self,command):
        command = command.rstrip()
        try:output = subprocess.run(command,shell=True,capture_output=True,text=True).stdout
        except:output = "ERRO\nComando invalido"
        return output.strip()
    
def main(): 
    try:
        is_to_listen = False
        is_to_recive_file = False
        is_to_execute_command = False
        file_to_send = None
        novo_sock = SOCKET()
        
        opts, _ = getopt.getopt(sys.argv[1:], 't:p:lerf:i', ['target_ip=','port=','listen','execute','recive','file=','localhost'])

        for command,arg in opts:
            if command in ('-i','--localhost'): novo_sock.my_ip =  "localhost"
            elif command in ('-t','--target_ip'): novo_sock.target_ip = arg
            elif command in ('-p','--port'): novo_sock.port = arg
            elif command in ('-l','--listen'): is_to_listen = True
            elif command in ('-e','--execute'): is_to_execute_command = True
            elif command in ('-r','--recive'): is_to_recive_file = True
            elif command in ('-f','--file'): file_to_send = arg
            else: raise getopt.GetoptError
        
        if is_to_listen:novo_sock.start_listen()
        elif file_to_send is not None:novo_sock.send_file(file_to_send)
        elif is_to_recive_file:novo_sock.recv_file()
        elif is_to_execute_command:novo_sock.execute_command()
        else:novo_sock.connect_to_target() 

    except KeyboardInterrupt:    
        print("\nEncerrando o servidor...")
        print("Servidor encerrado.")
    
    except getopt.GetoptError as err:
        uso()
        print(err)

    except Exception as e:
        uso()
        print(e)

main()